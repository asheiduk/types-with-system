/*
 * generated by Xtext
 */
package de.mathema.typesystem.validation

import de.mathema.typesystem.types.Type
import de.mathema.typesystem.types.TypeCalculator
import de.mathema.typesystem.types.TypeCompatibility
import de.mathema.typesystem.typesystem.CompareExpression
import de.mathema.typesystem.typesystem.EvalStatement
import de.mathema.typesystem.typesystem.Expression
import de.mathema.typesystem.typesystem.LogicalExpression
import de.mathema.typesystem.typesystem.PlusExpression
import de.mathema.typesystem.typesystem.SetStatement
import javax.inject.Inject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check

import static de.mathema.typesystem.types.TypeConstants.*
import static de.mathema.typesystem.typesystem.TypesystemPackage.Literals.*
import de.mathema.typesystem.typesystem.MinusExpression
import de.mathema.typesystem.typesystem.MultiplyExpression
import de.mathema.typesystem.typesystem.DivideExpression

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TypesystemValidator extends AbstractTypesystemValidator {

	@Inject extension TypeCalculator
	@Inject extension TypeCompatibility
	
	@Check
	def void checkCompareExpression(CompareExpression it){
		val leftType = left?.type
		val rightType = right?.type
		
		if( !leftType.isAssignableTo(rightType) && !rightType.isAssignableTo(leftType) ){
			val msg = '''Incompatible types: '«leftType.asString»' «op» '«rightType.asString»' '''
			error(msg, null)
		}
	}
	
	@Check 
	def void checkPlusExpression(PlusExpression it){
		checkOverloadedOperatorExpression(left, '+', right)
	}
	
	@Check
	def void checkMinusExpression(MinusExpression it){
		checkOverloadedOperatorExpression(left, '-', right)
	}
	
	@Check
	def void checkMultiplyExpression(MultiplyExpression it){
		checkOverloadedOperatorExpression(left, '-', right)
	}

	@Check
	def void checkDivideExpression(DivideExpression it){
		checkOverloadedOperatorExpression(left, '-', right)
	}
	
	def private checkOverloadedOperatorExpression(Expression it, Expression left, String op, Expression right){		
		val actualType = type; 
		if( actualType == null ){	// If there is no result type then something is wrong!
			val leftType = left.type
			val rightType = right.type
			val msg = '''Incompatible types: '«leftType.asString»' «op» '«rightType.asString»' '''
			error(msg, null)
		}
	}

	@Check
	def void checkExpectedType(Expression it){
		val actualType = type
		if( actualType == null ){
			val msg = '''Cannot calculate type.'''
			error(msg, null)
		}
		else {
			val expectedType = expectedType(eContainer, eContainingFeature)
			if( expectedType != null ){
				if( ! actualType.isAssignableTo(expectedType) ){
					val msg = '''Incompatible types: expected '«expectedType.asString»' but is actually '«actualType.asString»' '''
					error(msg, null)
				}
			}
		}
	}
	
	// ---------- Expressions ----------
	
	def private dispatch Type expectedType(Expression container, EStructuralFeature feature){
		null
	}
	
	def private dispatch Type expectedType(LogicalExpression container, EStructuralFeature feature){
		BOOLEAN_TYPE
	}

	// ---------- Non-Expressions ----------
	
	def private dispatch Type expectedType(SetStatement container, EStructuralFeature feature){
		switch(feature){
			case SET_STATEMENT__EXPR: container.^var.type
		}
	}
	
	def private dispatch Type expectedType(EvalStatement container, EStructuralFeature feature){
		ANY_TYPE
	}
}
